// Generated by CoffeeScript 1.6.3
(function() {
  var __slice = [].slice;

  (function() {
    var factory;
    factory = function() {
      var Parser, toJSON;
      toJSON = function(node) {
        var attribute, child, obj, _i, _j, _len, _len1, _ref, _ref1;
        obj = {};
        if (node.tagName) {
          obj.tagName = node.tagName.toLowerCase();
        } else if (node.nodeName) {
          obj.nodeName = node.nodeName.toLowerCase();
        }
        if (node.attributes) {
          obj.attributes = {};
          _ref = node.attributes;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            attribute = _ref[_i];
            obj.attributes[attribute.nodeName] = attribute.nodeValue;
          }
        }
        if (node.childNodes) {
          obj.childNodes = [];
          _ref1 = node.childNodes;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            child = _ref1[_j];
            if (child.nodeType === 1) {
              obj.childNodes.push(toJSON(child));
            }
          }
        }
        switch (node.nodeName) {
          case "OPTION":
            obj.isOption = true;
            obj.attributes["text"] = node.innerHTML;
            break;
          case "OPTGROUP":
            obj.isGroup = true;
        }
        return obj;
      };
      Parser = {
        parse: function(object) {
          return toJSON(object);
        }
      };
      return Parser;
    };
    if (typeof define === "function" && define.amd) {
      return define(factory);
    } else if (typeof module !== "undefined" && module.exports) {
      return module.exports = factory();
    } else {
      return window["parser"] = factory();
    }
  })();

  /* --------------------------------------------
       Begin renderer.coffee
  --------------------------------------------
  */


  (function() {
    var factory;
    factory = function() {
      var Renderer, expand, find, parse, templateCache;
      templateCache = {};
      find = function(name, stack, value) {
        var ctx, i, part, parts, _i, _j, _len, _ref, _ref1;
        if (value == null) {
          value = null;
        }
        if (name === ".") {
          return stack[stack.length - 1];
        }
        _ref = name.split(/\./), name = _ref[0], parts = 2 <= _ref.length ? __slice.call(_ref, 1) : [];
        for (i = _i = _ref1 = stack.length - 1; _ref1 <= -1 ? _i < -1 : _i > -1; i = _ref1 <= -1 ? ++_i : --_i) {
          if (stack[i] == null) {
            continue;
          }
          if (!(typeof stack[i] === "object" && name in (ctx = stack[i]))) {
            continue;
          }
          value = ctx[name];
          break;
        }
        for (_j = 0, _len = parts.length; _j < _len; _j++) {
          part = parts[_j];
          value = find(part, [value]);
        }
        if (value instanceof Function) {
          value = (function(value) {
            return function() {
              var val;
              val = value.apply(ctx, arguments);
              return (val instanceof Function) && val.apply(null, arguments) || val;
            };
          })(value);
        }
        return value;
      };
      expand = function() {
        var args, f, obj, tmpl;
        obj = arguments[0], tmpl = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
        return ((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = tmpl.length; _i < _len; _i++) {
            f = tmpl[_i];
            _results.push(f.call.apply(f, [obj].concat(__slice.call(args))));
          }
          return _results;
        })()).join("");
      };
      parse = function(template, delimiters, section) {
        var buffer, buildInterpolationTag, buildInvertedSectionTag, buildPartialTag, buildRegex, buildSectionTag, cache, content, contentEnd, d, error, escape, isStandAlone, match, name, parseError, pos, sectionInfo, tag, tagPattern, tmpl, type, whitespace, _name, _ref, _ref1, _ref2;
        if (delimiters == null) {
          delimiters = ["{{", "}}"];
        }
        if (section == null) {
          section = null;
        }
        cache = (templateCache[_name = delimiters.join(" ")] || (templateCache[_name] = {}));
        if (template in cache) {
          return cache[template];
        }
        buffer = [];
        buildRegex = function() {
          var tagClose, tagOpen;
          tagOpen = delimiters[0], tagClose = delimiters[1];
          return RegExp("([\\s\\S]*?)([" + ' ' + "\\t]*)(?:" + tagOpen + "\\s*(?:(!)\\s*([\\s\\S]+?)|(=)\\s*([\\s\\S]+?)\\s*?|({)\\s*(\\w[\\S]*?)\\s*}|([^0-9a-zA-Z._!={]?)\\s*([\\w.][\\S]*?))\\s*" + tagClose + ")", "gm");
        };
        tagPattern = buildRegex();
        tagPattern.lastIndex = pos = (section || {
          start: 0
        }).start;
        parseError = function(pos, msg) {
          var carets, e, endOfLine, error, indent, key, lastLine, lastTag, lineNo, parsedLines, tagStart;
          (endOfLine = /$/gm).lastIndex = pos;
          endOfLine.exec(template);
          parsedLines = template.substr(0, pos).split("\n");
          lineNo = parsedLines.length;
          lastLine = parsedLines[lineNo - 1];
          tagStart = contentEnd + whitespace.length;
          lastTag = template.substr(tagStart + 1, pos - tagStart - 1);
          indent = new Array(lastLine.length - lastTag.length + 1).join(" ");
          carets = new Array(lastTag.length + 1).join("^");
          lastLine = lastLine + template.substr(pos, endOfLine.lastIndex - pos);
          error = new Error();
          for (key in e = {
            "message": "" + msg + "\n\nLine " + lineNo + ":\n" + lastLine + "\n" + indent + carets,
            "error": msg,
            "line": lineNo,
            "char": indent.length,
            "tag": lastTag
          }) {
            error[key] = e[key];
          }
          return error;
        };
        while (match = tagPattern.exec(template)) {
          _ref = match.slice(1, 3), content = _ref[0], whitespace = _ref[1];
          type = match[3] || match[5] || match[7] || match[9];
          tag = match[4] || match[6] || match[8] || match[10];
          contentEnd = (pos + content.length) - 1;
          pos = tagPattern.lastIndex;
          isStandAlone = (contentEnd === -1 || template.charAt(contentEnd) === "\n") && ((_ref1 = template.charAt(pos)) === (void 0) || _ref1 === "" || _ref1 === "\r" || _ref1 === "\n");
          if (content) {
            buffer.push((function(content) {
              return function() {
                return content;
              };
            })(content));
          }
          if (isStandAlone && (type !== "" && type !== "&" && type !== "{")) {
            if (template.charAt(pos) === "\r") {
              pos += 1;
            }
            if (template.charAt(pos) === "\n") {
              pos += 1;
            }
          } else if (whitespace) {
            buffer.push((function(whitespace) {
              return function() {
                return whitespace;
              };
            })(whitespace));
            contentEnd += whitespace.length;
            whitespace = "";
          }
          switch (type) {
            case "!":
              break;
            case "":
            case "&":
            case "{":
              buildInterpolationTag = function(name, is_unescaped) {
                return function(context) {
                  var value, _ref2;
                  if ((value = (_ref2 = find(name, context)) != null ? _ref2 : "") instanceof Function) {
                    value = expand.apply(null, [this, parse("" + (value()))].concat(__slice.call(arguments)));
                  }
                  if (!is_unescaped) {
                    value = this.escape("" + value);
                  }
                  return "" + value;
                };
              };
              buffer.push(buildInterpolationTag(tag, type));
              break;
            case ">":
              buildPartialTag = function(name, indentation) {
                return function(context, partials) {
                  var partial;
                  partial = partials(name).toString();
                  if (indentation) {
                    partial = partial.replace(/^(?=.)/gm, indentation);
                  }
                  return expand.apply(null, [this, parse(partial)].concat(__slice.call(arguments)));
                };
              };
              buffer.push(buildPartialTag(tag, whitespace));
              break;
            case "#":
            case "^":
              sectionInfo = {
                name: tag,
                start: pos,
                error: parseError(tagPattern.lastIndex, "Unclosed section '" + tag + "'!")
              };
              _ref2 = parse(template, delimiters, sectionInfo), tmpl = _ref2[0], pos = _ref2[1];
              sectionInfo["#"] = buildSectionTag = function(name, delims, raw) {
                return function(context) {
                  var parsed, result, v, value;
                  value = find(name, context) || [];
                  tmpl = value instanceof Function ? value(raw) : raw;
                  if (!(value instanceof Array)) {
                    value = [value];
                  }
                  parsed = parse(tmpl || "", delims);
                  context.push(value);
                  result = (function() {
                    var _i, _len, _results;
                    _results = [];
                    for (_i = 0, _len = value.length; _i < _len; _i++) {
                      v = value[_i];
                      context[context.length - 1] = v;
                      _results.push(expand.apply(null, [this, parsed].concat(__slice.call(arguments))));
                    }
                    return _results;
                  }).apply(this, arguments);
                  context.pop();
                  return result.join("");
                };
              };
              sectionInfo["^"] = buildInvertedSectionTag = function(name, delims, raw) {
                return function(context) {
                  var value;
                  value = find(name, context) || [];
                  if (!(value instanceof Array)) {
                    value = [1];
                  }
                  value = value.length === 0 ? parse(raw, delims) : [];
                  return expand.apply(null, [this, value].concat(__slice.call(arguments)));
                };
              };
              buffer.push(sectionInfo[type](tag, delimiters, tmpl));
              break;
            case "/":
              if (section == null) {
                error = "End Section tag '" + tag + "' found, but not in section!";
              } else if (tag !== (name = section.name)) {
                error = "End Section tag closes '" + tag + "'; expected '" + name + "'!";
              }
              if (error) {
                throw parseError(tagPattern.lastIndex, error);
              }
              template = template.slice(section.start, +contentEnd + 1 || 9e9);
              cache[template] = buffer;
              return [template, pos];
            case "=":
              if ((delimiters = tag.split(/\s+/)).length !== 2) {
                error = "Set Delimiters tag should have two and only two values!";
              }
              if (error) {
                throw parseError(tagPattern.lastIndex, error);
              }
              escape = /[-[\]{}()*+?.,\\^$|#]/g;
              delimiters = (function() {
                var _i, _len, _results;
                _results = [];
                for (_i = 0, _len = delimiters.length; _i < _len; _i++) {
                  d = delimiters[_i];
                  _results.push(d.replace(escape, "\\$&"));
                }
                return _results;
              })();
              tagPattern = buildRegex();
              break;
            default:
              throw parseError(tagPattern.lastIndex, "Unknown tag type -- " + type);
          }
          tagPattern.lastIndex = pos != null ? pos : template.length;
        }
        if (section != null) {
          throw section.error;
        }
        if (template.length !== pos) {
          buffer.push(function() {
            return template.slice(pos);
          });
        }
        return cache[template] = buffer;
      };
      Renderer = {
        escape: function(value) {
          var entities;
          entities = {
            "$": "amp",
            '"': "quot",
            "<": "lt",
            ">": "gt"
          };
          return value.replace(/[&"<>]/g, function(ch) {
            return "&" + entities[ch] + ";";
          });
        },
        render: function(template, data, partials) {
          var context;
          if (partials == null) {
            partials = null;
          }
          if (!((partials || (partials = this.partials || {})) instanceof Function)) {
            partials = (function(partials) {
              return function(name) {
                if (!(name in partials)) {
                  throw "Unknow partial '" + name + "'!";
                }
                return find(name, [partials]);
              };
            })(partials);
          }
          context = this.helpers instanceof Array ? this.helpers : [this.helpers];
          return expand(this, parse(template), context.concat([data]), partials);
        }
      };
      return Renderer;
    };
    if (typeof define === "function" && define.amd) {
      return define([], factory);
    } else if (typeof module !== "undefined" && module.exports) {
      return module.exports = factory();
    } else {
      return window["renderer"] = factory();
    }
  })();

  /* --------------------------------------------
       Begin selektera.coffee
  --------------------------------------------
  */


  (function() {
    var factory;
    factory = function(renderer, parser, $) {
      $.Selektera = function(element, options) {
        var state;
        state = '';
        this.settings = {};
        this.$element = $(element);
        this.setState = function(_state) {
          return state = _state;
        };
        this.getState = function() {
          return state;
        };
        this.init = function() {
          var html, parsed;
          this.settings = $.extend({}, this.defaults, options);
          parsed = parser.parse(this.$element.context);
          html = renderer.render(this.settings.template, parsed);
          this.$element.hide().after($(html));
          $(".selektera-control").on("click", function(e) {
            var control;
            control = e.currentTarget;
            $(control).find(".selektera-input").toggleClass("dropdown-open");
            return $(control).find(".selektera-dropdown").toggleClass("open");
          });
          $(".selektera-option").on("click", function(e) {
            var $control, $selected, option;
            option = e.currentTarget;
            $control = $(option).parents(".selektera-control");
            $selected = $control.find(".selektera-option.selected");
            if ($selected) {
              $selected.removeClass("selected");
            }
            $(option).addClass("selected");
            return $control.find(".selektera-input").trigger("change", $(option).data("value"));
          });
          $(".selektera-input").on("change", function(e, data) {
            var $element, input;
            input = e.currentTarget;
            $element = $(input).find("input");
            return $element.val(data);
          });
          this.$element.remove();
          return this.setState("ready");
        };
        this.init();
        return this;
      };
      $.Selektera.prototype.defaults = {
        template: '<div class="selektera-control">' + '<div class="selektera-input">' + '<input name="{{attributes.name}}" {{#attributes.placeholder}}placeholder="{{attributes.placeholder}}"{{/attributes.placeholder}} disabled/>' + '</div>' + '<ul class="selektera-dropdown">' + '{{#childNodes}}' + '{{#isGroup}}' + '<li class="selektera-group">{{attributes.label}}' + '<ul>' + '{{#childNodes}}' + '<li class="selektera-option" data-value="{{attributes.value}}">{{attributes.text}}</li>' + '{{/childNodes}}' + '</ul>' + '</li>' + '{{/isGroup}}' + '{{#isOption}}' + '<li class="selektera-option" data-value="{{attributes.value}}">{{attributes.text}}</li>' + '{{/isOption}}' + '{{/childNodes}}' + '</ul>' + '</div>'
      };
      return $.fn.selektera = function(option) {
        return this.each(function() {
          if ($(this).data("selektera") === void 0) {
            return $(this).data("selektera", new $.Selektera(this, option));
          }
        });
      };
    };
    if (typeof define === "function" && define.amd) {
      return define(["renderer"], factory);
    } else if (typeof module !== "undefined" && module.exports) {
      return module.exports = factory(require("./renderer"));
    } else {
      return window["selektera"] = factory(window["renderer"], window["parser"], window["jQuery"]);
    }
  })();

}).call(this);
